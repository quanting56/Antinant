<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!-- Title -->
    <title>測試區</title>

    <!-- Bootstrap CSS -->
    <link rel="stylesheet" href="../css/bootstrap_5.3.3_css/bootstrap.min.css"/>
    <link rel="stylesheet" href="../css/bootstrap_icons-main/font/bootstrap-icons.css"/>
    <link rel="stylesheet" href="../css/font_awesome_v6.5.2_all.css" type="text/css" />
    <link rel="stylesheet" href="../css/animate_v4.1.1_min.css">
    <link rel="stylesheet" href="../css/vs2015_min.css">
    <link rel="stylesheet" href="../css/main.css"/>

    <!-- jQuery -->
    <script src="../js/jquery_v3.7.1_min.js"></script>
    <!-- Bootstrap Bundle JS -->
    <script src="../js/bootstrap_5.3.3_js/bootstrap.bundle.min.js"></script>
    <script src="../js/d3_v7.9.0_min.js"></script>
    <script src="../js/wow_v1.1.3_min.js"></script>
    <script src="../js/highlight_min.js"></script>
    <script src="../js/script.js"></script>

    <!-- // 啟用 Highlight.js -->
    <script>hljs.highlightAll();</script>

    <style>
      body {
        padding: 30px;
      }

      li {
        padding-top: 30px;
      }
    </style>
  </head>
  <body>
    <h2>歡迎來到測試場</h2>
    <hr>
    <ol>
      <li>
        基礎長條圖
        <div id="barChart"></div>
        <div id="btnWrap">
          <button id="barChartApril2024Btn" class="btn btn-outline-warning" onclick="updateElectricChart('../data/taipowerData/202404.csv')">2024 4月</button>
          <button id="barChartMay2024Btn" class="btn btn-outline-warning" onclick="updateElectricChart('../data/taipowerData/202405.csv')">2024 5月</button>
          <button id="barChartJune2024Btn" class="btn btn-outline-warning" onclick="updateElectricChart('../data/taipowerData/202406.csv')">2024 6月</button>
        </div>
        <script>
          // 建立svg
          const barChartWidth = 750;
          const barChartHeight = 500;
          const barChartMargin = {top: 40, right: 40, bottom: 40, left: 80};
          const barChartSVG = d3.select("#barChart")
                                .append("svg")
                                .attr("width", barChartWidth)
                                .attr("height", barChartHeight);

          // 建立初始X軸
          const xScale = d3.scaleBand()
                           .range([barChartMargin.left, barChartWidth - barChartMargin.right])
                           .padding(0.2);
          const xAxisGenerator = d3.axisBottom(xScale);
          const xAxis = barChartSVG.append("g")
                                   .attr("transform", `translate(0, ${barChartHeight - barChartMargin.bottom})`);

          // 建立初始Y軸
          const yScale = d3.scaleLinear()
                           .range([barChartHeight - barChartMargin.bottom, barChartMargin.top]);
          const yAxisGenerator = d3.axisLeft(yScale)
                                   .ticks(5)
                                   .tickSize(3);
          const yAxis = barChartSVG.append("g")
                                   .attr("transform", `translate(${barChartMargin.left}, 0)`);

          // 取得資料
          const updateElectricChart = async (url) => {
            const data = await d3.csv(url);
            // map資料集
            xData = data.map((i) => i["縣市"]);
            yData = data.map((i) => parseInt(i["合計售電量_度"].split(",").join("")));

            // 設定X軸Domain、建立X軸
            xScale.domain(xData);
            xAxis.transition().duration(1000).call(xAxisGenerator);

            // 調整X軸刻度文字標籤傾斜
            xAxis.selectAll("text")
                 .attr("transform", "translate(-10, 0) rotate(-45)")
                 .style("text-anchor", "end");

            // 設定Y軸Domain、建立Y軸
            yScale.domain([0, d3.max(yData)]).nice();
            yAxis.transition().duration(1000).call(yAxisGenerator);

            // 開始建立長條圖
            const bar = barChartSVG.selectAll("rect")
                                   .data(data)
                                   .join("rect");

            // 加上漸增動畫
            // 注意：如果要加動畫，事件要分開寫
            bar.transition()
               .duration(1000)
               .attr("x", d => xScale(d["縣市"]))
               .attr("y", d => yScale(parseInt(d["合計售電量_度"].split(",").join(""))))
               .attr("width", xScale.bandwidth())
               .attr("height", d => ( barChartHeight - barChartMargin.bottom ) - yScale(parseInt(d["合計售電量_度"].split(",").join(""))) )
               .attr("fill", "#69b3a2");

            // 加上滑鼠事件
            bar.style("cursor", "pointer")
               .on("mouseover", handleMouseOver)
               .on("mouseleave", handleMouseLeave)
               
            function handleMouseOver(d) {
              d3.select(this).attr("fill", "#f68b47");

              // 加上文字標籤
              barChartSVG.append("text")
                         .attr("class", "barChartInfoText")
                         .attr("x", xScale(d.target.__data__["縣市"]))
                         .attr("y", yScale(parseInt(d.target.__data__["合計售電量_度"].split(",").join(""))))
                         .style("fill", "#121212")
                         .style("font-size", "18px")
                         .style("font-weight", "bold")
                         .style("text-anchor", "middle")
                         .text(d.target.__data__["合計售電量_度"] + " 度");
            };

            function handleMouseLeave() {
              d3.select(this).attr("fill", "#69b3a2")
              barChartSVG.select(".barChartInfoText").remove();
            };
          };
          updateElectricChart('../data/taipowerData/202404.csv');
        </script>
      </li>
      <li>
        複數長條圖
        <div id="multiBarChart"></div>
        <script>
          const multiBarChartWidth = 750;
          const multiBarChartHeight = 500;
          const multiBarChartMargin = {top: 20, right: 20, bottom: 100, left: 40};
          const multiBarChartData = [
            {"年度": 2017, "15~24歲(千人)": 80, "25~44歲(千人)": 506, "45~64歲(千人)": 381, "65歲及以上(千人)": 35},
            {"年度": 2018, "15~24歲(千人)": 80, "25~44歲(千人)": 508, "45~64歲(千人)": 392, "65歲及以上(千人)": 38},
            {"年度": 2019, "15~24歲(千人)": 82, "25~44歲(千人)": 511, "45~64歲(千人)": 398, "65歲及以上(千人)": 39},
            {"年度": 2020, "15~24歲(千人)": 79, "25~44歲(千人)": 504, "45~64歲(千人)": 387, "65歲及以上(千人)": 42}
          ];
          const multiBarChartSVG = d3.select("#multiBarChart")
                                     .append("svg")
                                     .attr("width", multiBarChartWidth)
                                     .attr("height", multiBarChartHeight);

          // 設定要給X軸用的scale和axis
          const multiBarChartXData = multiBarChartData.map((d) => d["年度"])
          const multiBarChartXScale = d3.scaleBand()
                                        .domain(multiBarChartXData)
                                        .range([multiBarChartMargin.left, multiBarChartWidth - multiBarChartMargin.right])
                                        .padding(0.2);
          const multiBarChartXAxisGenerator = d3.axisBottom(multiBarChartXScale);

          // 呼叫繪製X軸、調整X軸位置
          const multiBarChartXAxisGroup = multiBarChartSVG.append("g")
                                                          .attr("transform", `translate(0, ${multiBarChartHeight - multiBarChartMargin.bottom})`)
                                                          .call(multiBarChartXAxisGenerator);

          // 設定要給Y軸用的scale和axis
          const multiBarChartYScale = d3.scaleLinear()
                                        .domain([0, 600])
                                        .range([multiBarChartHeight - multiBarChartMargin.bottom, multiBarChartMargin.top])
                                        .nice();

          const multiBarChartYAxisGenerator = d3.axisLeft(multiBarChartYScale).ticks(5).tickSize(3);

          // 呼叫繪製Y軸、調整Y軸位置
          const multiBarChartYAxisGroup = multiBarChartSVG.append("g")
                                                          .attr("transform", `translate(${multiBarChartMargin.left}, 0)`)
                                                          .call(multiBarChartYAxisGenerator);

          // 設定第2條X軸資料、比例尺
          // 用來設定「多條長條圖」的位置
          const multiBarChartSubGroups = Object.keys(multiBarChartData[0]).slice(1);
          const multiBarChartXSubgroup = d3.scaleBand()
                                           .domain(multiBarChartSubGroups)
                                           .range([0, multiBarChartXScale.bandwidth()])
                                           .padding(0.05);

          // 設定不同subgroup bar的顏色
          const multiBarChartColor = d3.scaleOrdinal()
                                       .domain(multiBarChartSubGroups)
                                       .range(["#d4be92", "#c2cccd", "#b2c2e3", "#ead0d1"])

          // 開始建立長條圖
          const multiBarChartBar = multiBarChartSVG.append("g")
                                                   .selectAll("g")
                                                   .data(multiBarChartData)
                                                   .join("g")
                                                   .attr("transform", d => `translate(${multiBarChartXScale(d["年度"])}, 0)`)
                                                   .selectAll("rect")
                                                   .data(d => multiBarChartSubGroups.map(key => {return {key: key, value: d[key]}}))
                                                   .join("rect")
                                                   .attr("x", d => multiBarChartXSubgroup(d.key))
                                                   .attr("y", d => multiBarChartYScale(d.value))
                                                   .attr("width", multiBarChartXSubgroup.bandwidth())
                                                   .attr("height", d => (multiBarChartHeight - multiBarChartMargin.bottom) - multiBarChartYScale(d.value))
                                                   .attr("fill", d => multiBarChartColor(d.key))
                                                   .style("cursor", "pointer")
                                                   .on("mouseover", multiBarChartHandleMouseOver)
                                                   .on("mousemove", multiBarChartHandleMouseMove)
                                                   .on("mouseleave", multiBarChartHandleMouseLeave);

          function multiBarChartHandleMouseOver(e) {
            const pt = d3.pointer(e, multiBarChartSVG.node());

            // 加上文字標籤
            multiBarChartSVG.append("text")
                            .attr("class", "multiBarChartInfoText")
                            .attr("x", multiBarChartMargin.left)
                            .attr("y", multiBarChartYScale(e.target.__data__["value"]))
                            .style("fill", "#121212")
                            .style("font-size", "18px")
                            .style("font-weight", "bold")
                            .style("text-anchor", "middle")
                            .text(e.target.__data__["value"] + "千人");
                          
            // 加上標示用輔助虛線
            multiBarChartSVG.append("line")
                            .attr("class", "multiBarChartDashedY")
                            .attr("x1", multiBarChartMargin.left)
                            .attr("y1", multiBarChartYScale(e.target.__data__["value"]))
                            .attr("x2", pt[0])
                            .attr("y2", multiBarChartYScale(e.target.__data__["value"]))
                            .style("stroke", "black")
                            .style("stroke-dasharray", 3);
          };

          function multiBarChartHandleMouseMove (e) {
            const pt = d3.pointer(e, multiBarChartSVG.node());
            multiBarChartSVG.selectAll(".multiBarChartDashedY")
                            .attr("x2", pt[0]);
          };

          function multiBarChartHandleMouseLeave() {
            multiBarChartSVG.select(".multiBarChartInfoText").remove();
            multiBarChartSVG.select(".multiBarChartDashedY").remove();
          };

          // 加上辨識標籤
          const multiBarChartTagsWrap = multiBarChartSVG.append("g")
                                                        .selectAll("g")
                                                        .data(multiBarChartSubGroups)
                                                        .join("g")
                                                        .attr("class", "multiBarChartTags");

          multiBarChartTagsWrap.append("rect")
                               .attr("x", (d, i) => ( i + 1 ) * multiBarChartMargin.bottom * 1.3)
                               .attr("y", multiBarChartHeight - multiBarChartMargin.bottom / 2)
                               .attr("width", 20)
                               .attr("height", 20)
                               .attr("fill", (d) => multiBarChartColor(d));

          multiBarChartTagsWrap.append("text")
                               .attr("x", (d, i) => ( i + 1 ) * multiBarChartMargin.bottom * 1.3)
                               .attr("y", multiBarChartHeight - multiBarChartMargin.bottom / 2 + 40)
                               .style("fill", "#121212")
                               .style("font-size", "12px")
                               .style("font-weight", "bold")
                               .style("text-anchor", "middle")
                               .text(d => d);
        </script>
      </li>
      <li>
        堆疊長條圖
        <div id="stackedBarChart"></div>
        <script>
          const stackedBarChartWidth = 750;
          const stackedBarChartHeight = 500;
          const stackedBarChartMargin = {top: 20, right: 20, bottom: 100, left: 40};
          const stackedBarChartData = [
            {"年度": 2017, "15~24歲(千人)": 80, "25~44歲(千人)": 506, "45~64歲(千人)": 381, "65歲及以上(千人)": 35},
            {"年度": 2018, "15~24歲(千人)": 80, "25~44歲(千人)": 508, "45~64歲(千人)": 392, "65歲及以上(千人)": 38},
            {"年度": 2019, "15~24歲(千人)": 82, "25~44歲(千人)": 511, "45~64歲(千人)": 398, "65歲及以上(千人)": 39},
            {"年度": 2020, "15~24歲(千人)": 79, "25~44歲(千人)": 504, "45~64歲(千人)": 387, "65歲及以上(千人)": 42}
          ];
          const stackedBarChartSVG = d3.select("#stackedBarChart")
                                       .append("svg")
                                       .attr("width", stackedBarChartWidth)
                                       .attr("height", stackedBarChartHeight);

          // 設定要給X軸用的scale和axis
          const stackedBarChartXData = stackedBarChartData.map((d) => d["年度"])
          const stackedBarChartXScale = d3.scaleBand()
                                          .domain(stackedBarChartXData)
                                          .range([stackedBarChartMargin.left, stackedBarChartWidth - stackedBarChartMargin.right])
                                          .padding(0.2);
          const stackedBarChartXAxisGenerator = d3.axisBottom(stackedBarChartXScale);

          // 呼叫繪製X軸、調整X軸位置
          const stackedBarChartXAxisGroup = stackedBarChartSVG.append("g")
                                                              .attr("transform", `translate(0, ${stackedBarChartHeight - stackedBarChartMargin.bottom})`)
                                                              .call(stackedBarChartXAxisGenerator);

          // 設定要給Y軸用的scale和axis
          const stackedBarChartYScale = d3.scaleLinear()
                                          .domain([0, 1200])
                                          .range([stackedBarChartHeight - stackedBarChartMargin.bottom, stackedBarChartMargin.top])
                                          .nice();

          const stackedBarChartYAxisGenerator = d3.axisLeft(stackedBarChartYScale).ticks(5).tickSize(3);

          // 呼叫繪製Y軸、調整Y軸位置
          const stackedBarChartYAxisGroup = stackedBarChartSVG.append("g")
                                                              .attr("transform", `translate(${stackedBarChartMargin.left}, 0)`)
                                                              .call(stackedBarChartYAxisGenerator);
                                                        
          // 設定分組，用d3.stack()把資料堆疊起來
          const stackedBarChartSubGroups = Object.keys(stackedBarChartData[0]).slice(1);
          const stackedBarChartStackedData = d3.stack().keys(stackedBarChartSubGroups)(stackedBarChartData);

          // 設定不同subgroup bar的顏色
          const stackedBarChartColor = d3.scaleOrdinal()
                                         .domain(stackedBarChartSubGroups)
                                         .range(["#97a9bf", "#d6dbbb", "#d4e6e8", "#dcd2d0"]);

          // 開始建立長條圖
          const stackedBarChartBar = stackedBarChartSVG.append("g")
                                                       .selectAll("g")
                                                       .data(stackedBarChartStackedData)
                                                       .join("g")
                                                       .attr("fill", (d) => stackedBarChartColor(d.key))
                                                       .selectAll("rect")
                                                       .data(d => d)
                                                       .join("rect")
                                                       .attr("x", (d) => stackedBarChartXScale(d.data["年度"]))
                                                       .attr("y", (d) => stackedBarChartYScale(d[1]))
                                                       .attr("height", d => stackedBarChartYScale(d[0]) - stackedBarChartYScale(d[1]))
                                                       .attr("width", stackedBarChartXScale.bandwidth())
                                                       .style("cursor", "pointer")
                                                       .on("mouseover", stackedBarChartColorHandleMouseOver)
                                                       .on("mousemove", stackedBarChartColorHandleMouseMove)
                                                       .on("mouseleave", stackedBarChartColorHandleMouseLeave);
                                                  
          function stackedBarChartColorHandleMouseOver(e) {
            const pt = d3.pointer(e, stackedBarChartSVG.node());
            d3.select(this).style("opacity", "0.5");

            // 加上文字標籤
            stackedBarChartSVG.append("text")
                              .attr("class", "stackedBarChartInfoText")
                              .style("fill", "#121212")
                              .style("font-size", "18px")
                              .style("font-weight", "bold")
                              .style("text-anchor", "start")
                              .attr("x", pt[0])
                              .attr("y", pt[1] - 20)
                              .text((e.target.__data__[1] - e.target.__data__[0]) + " 千人");
          };

          function stackedBarChartColorHandleMouseMove(e) {
            const pt = d3.pointer(e, stackedBarChartSVG.node());
            stackedBarChartSVG.select(".stackedBarChartInfoText")
                              .attr("x", pt[0] + 10)
                              .attr("y", pt[1] - 15);
          }

          function stackedBarChartColorHandleMouseLeave() {
            d3.select(this).style("opacity", "1");
            stackedBarChartSVG.select(".stackedBarChartInfoText").remove();
          };

          // 加上辨識標籤
          const stackedBarChartTagsWrap = stackedBarChartSVG.append("g")
                                                            .selectAll("g")
                                                            .data(stackedBarChartSubGroups)
                                                            .join("g")
                                                            .attr("class", "stackedBarChartTags");

          stackedBarChartTagsWrap.append("rect")
                                 .attr("x", (d, i) => ( i + 1 ) * stackedBarChartMargin.bottom * 1.3)
                                 .attr("y", stackedBarChartHeight - stackedBarChartMargin.bottom / 2)
                                 .attr("width", 20)
                                 .attr("height", 20)
                                 .attr("fill", (d) => stackedBarChartColor(d));

          stackedBarChartTagsWrap.append("text")
                                 .attr("x", (d, i) => ( i + 1 ) * stackedBarChartMargin.bottom * 1.3)
                                 .attr("y", stackedBarChartHeight - stackedBarChartMargin.bottom / 2 + 40)
                                 .style("fill", "#121212")
                                 .style("font-size", "12px")
                                 .style("font-weight", "bold")
                                 .style("text-anchor", "middle")
                                 .text(d => d);
                                                       
        </script>
      </li>
      <li>
        基礎折線圖
        <div id="housePriceLineChart"></div>
        <!-- 引用Day.js函式庫 -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.7/dayjs.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/dayjs/1.11.7/locale/zh-tw.min.js"></script>
        <script>
          // 先設一個函式轉換日期格式
          // 中華民國年份改成西元
          const ROCDateToADDate = (date) => {
            // 年份轉換
            date = date.replace(/\d{3}/, (match => String(+match + 1911)));

            // 季度換成每季第一天
            // 定義一個對應表，用於將季度表示（如Q1, Q2）轉換成對應的日期
            const seasonDates = {
              Q1: "-01-01",
              Q2: "-04-01",
              Q3: "-07-01",
              Q4: "-10-01"
            };

            const season = date.match(/Q\d/)[0];  // 找到季度表示（如Q1, Q2），因為'.match()'會返回一個陣列（此處為單元素陣列），所以需要用[0]取出該元素
            date = date.replace(season, seasonDates[season]);  // 用對應的日期替換季度表示
            return new Date(date);  // 將處理後的字串轉換成Date物件，並回傳
          };

          // 折線圖繪圖函式
          const housePriceLineChart = async () => {
            // 設定svg
            const width = 600;
            const height = 400;
            const margin = {top: 20, bottom: 90, right: 20, left: 60};
            const svg = d3.select("#housePriceLineChart")
                          .append("svg")
                          .attr("width", width)
                          .attr("height", height);
                
            // 取資料（資料格式要注意）
            const res = await d3.csv("../data/housePrice/南港96Q3至113Q1買賣契約價格平均總價.csv")
            const data = res.map((i) => {
              i["date"] = ROCDateToADDate(i["date"]);
              return i;
            });  // 日期格式轉換

            // map資料集
            const xData = data.map((i) => i["date"]);
            const yData = data.map((i) => +i["price"]);

            // Time Axis
            const xScale = d3.scaleTime()
                             .domain(d3.extent(xData))
                             .range([margin.left, width - margin.right])
                             .nice();
            let tickNumber = window.innerWidth > 900 ? (xData.length / 3) : 10 ;  // 根據視窗不同寬來調整tick數量
            const xAxisGenerator = d3.axisBottom(xScale)
                                     .ticks(tickNumber)
                                     .tickFormat((d) => dayjs(d).format("YYYY/MM/DD"));
            const xAxis = svg.append("g")
                             .attr("transform", `translate(0, ${height - margin.bottom})`)
                             .call(xAxisGenerator)
                             .style("font-size", "12px");

            xAxis.selectAll(".tick text")
                 .attr("transform", "rotate(-45)")
                 .attr("x", "-35")
                 .attr("y", "6");

            // Price Axis
            const yScale = d3.scaleLinear()
                             .domain(d3.extent(yData))
                             .range([height - margin.bottom, margin.top])
                             .nice();
            const yAxisGenerator = d3.axisLeft(yScale).tickFormat((d) => d + "萬");
            // 上行也可以寫成'const yAxisGenerator = d3.axisLeft(yScale).tickFormat((d) => `${d}萬`);'
            const yAxis = svg.append("g")
                             .attr("transform", `translate(${margin.left}, 0)`)
                             .call(yAxisGenerator);

            // 設定path的d
            const lineChart = d3.line()
                                .x((d) => xScale(d["date"]))
                                .y((d) => yScale(+d["price"]));

            // 建立折線圖
            svg.append("path")
               .data(data)
               .attr("d", lineChart(data))
               .attr("fill", "none")
               .attr("stroke", "#f68b47")
               .attr("stroke-width", 1.5);
          };
          housePriceLineChart();
        </script>
      </li>
      <li>
        有滑鼠互動效果的折線圖
        <div id="interactLineChart"></div>
        <script>
          const interactLineChart = async () => {
            const width = 600;
            const height = 400;
            const margin = 80;
            const svg = d3.select("#interactLineChart")
                          .append("svg")
                          .attr("width", width)
                          .attr("height", height);

            const res = await d3.csv("../data/disease/後天免疫缺乏症候群趨勢.csv");
            const data = res.filter(i => i["診斷年週"] < "202401");
            // map資料集
            const xData = data.map((i) => +i["診斷年週"].substring(4,6));
            const yData = data.map((i) => +i["確定病例數"]);

            // Time Axis
            const xScale = d3.scaleLinear()
                             .domain(d3.extent(xData))
                             .range([margin, width - margin])
                             .nice();
            const xAxisGenerator = d3.axisBottom(xScale)
                                     .tickFormat(d => "第" + d + "週");
            const xAxis = svg.append("g")
                             .attr("transform", `translate(0, ${height - margin})`)
                             .call(xAxisGenerator);

            // Number_of_cases Axis
            const yScale = d3.scaleLinear()
                             .domain([0, d3.max(yData)])
                             .range([height - margin, margin])
                             .nice();
            const yAxisGenerator = d3.axisLeft(yScale).ticks(5);
            const yAxis = svg.append("g")
                             .attr("transform", `translate(${margin}, 0)`)
                             .call(yAxisGenerator);

            // 開始建立折線圖，設定折線圖相關資料
            const lineChart = d3.line()
                                .x((d) => xScale(+d["診斷年週"].substring(4, 6)))
                                .y((d) => yScale(+d["確定病例數"]));
            svg.append("path")
               .data(data)
               .attr("d", lineChart(data))
               .attr("fill", "none")
               .attr("stroke", "#f68b47")
               .attr("stroke-width", 1.5);

            // 建立一個覆蓋SVG的方形
            svg.append("rect")
               .style("fill", "transparent")
               .style("pointer-events", "all")
               .attr("width", width - margin)
               .attr("height", height - margin)
               .style("cursor", "pointer")
               .on("mouseover", mouseover)
               .on("mousemove", mousemove)
               .on("mouseout", mouseout);

            // 建立沿著折線移動的圓點點
            const focusDot = svg.append("g")
                                .append("circle")
                                .style("fill", "black")
                                .attr("stroke", "black")
                                .attr("r", 3)
                                .style("opacity", 0);

            // 建立移動的資料標籤
            const focusText = svg.append("text")
                                 .style("opacity", 0)
                                 .attr("text-anchor", "left")
                                 .attr("alignment-baseline", "middle");

            // 使用d3.bisector()找到根據資料的"診斷年週"對應的資料點
            const bisect = d3.bisector(d => d["診斷年週"]).left;

            // 設定滑鼠事件
            function mouseover() {
              focusDot.style("opacity", 1);
              focusText.style("opacity", 1);
            };

            function mousemove(e) {
              // 把目前X的位置用xScale去換算
              const x0 = xScale.invert(d3.pointer(e, this)[0]);
              // 由於X軸資料是擷取過的，這裡要整理並補零（整數部分先轉換為字串，並補足兩位數（如 01, 02, ...））
              const fixedX0 = parseInt(x0).toString().padStart(2, "0");
              // 接者把擷取掉的2023補回來，因為data是帶入原本的資料
              let i = bisect(data, "2023" + fixedX0);
              let selectedData = data[i];

              // 圓點
              focusDot.attr("cx", xScale(selectedData["診斷年週"].substring(4, 6)))
                      .attr("cy", yScale(selectedData["確定病例數"]));

              focusText.html("確診病例數：" + selectedData["確定病例數"])
                       .attr("x", xScale(selectedData["診斷年週"].substring(4, 6)) + 15)
                       .attr("y", yScale(selectedData["確定病例數"]));
            };

            function mouseout() {
              focusDot.style("opacity", 0);
              focusText.style("opacity", 0);
            };
          };
          interactLineChart();
        </script>
      </li>
      <li>
        缺少部分資料的折線圖
        <div id="definedLineChart"></div>
        <script>
          const definedLineChart = () => {
            const width = 600;
            const height = 400;
            const margin = 50;
            const data = [
              {x: 1, y: 120},
              {x: 2, y: 355},
              {x: 3, y: 0},
              {x: 4, y: 470},
              {x: 5, y: 19},
              {x: 6, y: 90},
              {x: 7, y: 0},
              {x: 8, y: 220},
            ];
            const svg = d3.select("#definedLineChart")
                          .append("svg")
                          .attr("width", width)
                          .attr("height", height);
            const xData = data.map((d) => d.x);
            const yData = data.map((d) => d.y);

            const xScale = d3.scaleLinear()
                             .domain([0, d3.max(xData)])
                             .range([margin, width - margin])
                             .nice();
            const xAxisGenerator = d3.axisBottom(xScale)
            const xAxis = svg.append("g")
                             .attr("transform", `translate(0, ${height - margin})`)
                             .call(xAxisGenerator);

            const yScale = d3.scaleLinear()
                             .domain([0, d3.max(yData)])
                             .range([height - margin, margin])
                             .nice();
            const yAxisGenerator = d3.axisLeft(yScale)
            const yAxis = svg.append("g")
                             .attr("transform", `translate(${margin}, 0)`)
                             .call(yAxisGenerator);

            // 用line.defined過濾掉是零的數值，設定只回傳y大於0的數值
            const lineChart = d3.line()
                                .x((d) => xScale(d.x))
                                .y((d) => yScale(d.y))
                                .defined((d) => d.y > 0);

            svg.append("path")
               .data(data)
               .attr("d", lineChart(data))
               .attr("fill", "none")
               .attr("stroke", "#f68b47")
               .attr("stroke-width", 2.5);

            // 把d.y大於零的資料拉出來，另外用這些資料去建立連線
            let filteredData = data.filter(d => d.y > 0);  // 也可以用lineChart.defined()

            // 建立dashed折線
            svg.append("path")
               .data(data)
               .attr("d", lineChart(filteredData))
               .attr("fill", "none")
               .attr("stroke", "#f68b47")
               .attr("stroke-width", "2.5")
               .attr("stroke-dasharray", "4, 4");

            // 加上tooltip
            const tooltip = d3.select("#definedLineChart")
                              .style("position", "relative")
                              .append("div")
                              .style("position", "absolute")
                              .style("opacity", "0")
                              .style("background-color", "white")
                              .style("border", "1px solid black")
                              .style("border-radius", "5px")
                              .style("padding", "5px");

            // 加上圓點點
            svg.append("g")
               .selectAll("circle")
               .data(filteredData)
               .join("circle")
               .attr("cx", (d) => xScale(d.x))
               .attr("cy", (d) => yScale(d.y))
               .attr("r", "5")
               .attr("fill", "white")
               .attr("stroke", "#f68b47")
               .attr("stroke-width", "2")
               .style("cursor", "pointer")
               .on("mouseover", dotsMouseover)
               .on("mouseleave", dotsMouseleave);

            function dotsMouseover(e) {
              let pt = d3.pointer(e, e.target);
              tooltip.style("opacity", "1")
                     .style("left", pt[0] + 20 + "px")
                     .style("top", pt[1] + "px")
                     .html(`x值：${e.target.__data__.x}<br>` + 
                           `y值：${e.target.__data__.y}`
                     );

              // 加上X-dashed線
              svg.append("line")
                 .attr("class", "d3jsDefinedLineChartDashedX")
                 .attr("x1", xScale(e.target.__data__.x))
                 .attr("y1", height - margin)
                 .attr("x2", xScale(e.target.__data__.x))
                 .attr("y2", margin)
                 .attr("stroke", "#f68b46")
                 .attr("stroke-dasharray", "4");

              // 加上Y-dashed線
              svg.append("line")
                 .attr("class", "d3jsDefinedLineChartDashedY")
                 .attr("x1", margin)
                 .attr("y1", yScale(e.target.__data__.y))
                 .attr("x2", width - margin)
                 .attr("y2", yScale(e.target.__data__.y))
                 .style("stroke", "#f68b47")
                 .style("stroke-dasharray", "4");
            };

            function dotsMouseleave(d) {
              tooltip.style("opacity", 0)
              svg.selectAll(".d3jsDefinedLineChartDashedX").remove();
              svg.selectAll(".d3jsDefinedLineChartDashedY").remove();
            };
          };
          definedLineChart();
        </script>
      </li>
      <li>
        多線折線圖
        <div id="multiLineChart"></div>
        <script>
          const multiLineChart = async () => {
            // svg
            const width = 600;
            const height = 400;
            const margin = 50;
            const svg = d3.select("#multiLineChart")
                          .append("svg")
                          .attr("width", width)
                          .attr("height", height);

            // 取資料集
            const res = await d3.json("https://data.moa.gov.tw/Service/OpenData/TransService.aspx?UnitId=5n9c3AlEJ2DH&IsTransData=1");
            const data = res.filter(d => d.observeDate.substring(0, 4) === "2023")  // 只取2023年的資料
            const xData = data.map((i) => i.observeDate.substring(4, 6));
            const yData = data.map((i) => {
              let rainfall = parseFloat(i.rainfall);
              return rainfall = rainfall || 0;  // 如果rainfall的值是NaN、null、undefined、0或""（空字串），那麼rainfall會被設定為0，否則保持原來的值
            });

            // X軸
            const xScale = d3.scaleLinear()
                             .domain(d3.extent(xData))
                             .range([margin, width - margin])
                             .nice();
            const xAxisGenerator = d3.axisBottom(xScale)
                                     .ticks(8)
                                     .tickFormat(d => d + "月");
            const xAxis = svg.append("g")
                             .attr("transform", `translate(0, ${height - margin})`)
                             .call(xAxisGenerator);

            // Y軸
            const yScale = d3.scaleLinear()
                             .domain(d3.extent(yData))
                             .range([height - margin, margin])
                             .nice();
            const yAxisGenerator = d3.axisLeft(yScale).tickFormat(d => d + "mm");
            const yAxis = svg.append("g")
                             .attr("transform", `translate(${margin}, 0)`)
                             .call(yAxisGenerator);

            // 把資料按照name分組
            const sumName = d3.group(data, d => d.observatory);
            const color = d3.scaleOrdinal()
                            .domain(data.map(d => d.item))  // 此資料沒有item項，因此此同'.domain()'，即domain是空的
                            .range(d3.schemeCategory10);

            // 建立tooltip
            const nameTag = d3.select("#multiLineChart")
                              .style("position", "relative")
                              .append("div")
                              .attr("class", "d3jsMultiLineChartNameTag")
                              .style("position", "absolute")
                              .style("background-color", "#121212")
                              .style("color", "#f2f2f2")
                              .style("border-radius", "5px")
                              .style("padding", "10px")
                              .style("display", "none");
            // 開始建立折線圖
            svg.append("g")
               .selectAll("path")
               .data(sumName)
               .join("path")
               .attr("d", d => {
                 return d3.line()
                          .x((d) => xScale(d.observeDate.substr(4, 6)))
                          .y((d) => {
                            let rainfall = parseFloat(d.rainfall);
                            rainfall = rainfall || 0
                            return yScale(rainfall)
                          })(d[1])  // 因為是從sumName裡面取資料，除了觀測站（observatory）以外的資料都在d[1]裡
               })
               .attr("fill", "none")
               .attr("stroke", d => color(d))
               .attr("stroke-width", 1.5)
               .style("cursor", "pointer")
               .on("mouseover", handleMouseover)
               .on("mouseleave", handleMouseleave);
            
            function handleMouseover(e) {
              let pt = d3.pointer(e, e.target);
              d3.select(this).style("stroke-width", "5");
              
              nameTag.style("display", "block")
                     .html(e.target.__data__[0])  // 因為已用'd3.group()'分組，所以此處'e.target.__data__[0]'代表觀測站名稱
                     .style("left", pt[0] + 10 + "px")
                     .style("top", pt[1] + "px");
            };

            function handleMouseleave() {
              d3.select(this).style("stroke-width", "1.5");
              nameTag.style("display", "none");
            };
          };
          multiLineChart();
        </script>
      </li>
      <li>
        多線折線圖搭配選取刷
        <div id="multiLineChartWithBrush"></div>
        <script>
          const multiLineChartWithBrush = async () => {
            // svg
            const width = 600;
            const height = 400;
            const margin = 50;
            const svg = d3.select("#multiLineChartWithBrush")
                          .append("svg")
                          .attr("width", width)
                          .attr("height", height);

            // 取資料集
            const data = await d3.json("https://data.moa.gov.tw/Service/OpenData/TransService.aspx?UnitId=5n9c3AlEJ2DH&IsTransData=1");
            const xData = data.map((d) => d3.timeParse("%Y%m")(d.observeDate));
            const yData = data.map((d) => {
              let rainfall = parseFloat(d.rainfall);
              return rainfall = rainfall || 0;  // 如果rainfall的值是NaN、null、undefined、0或""（空字串），那麼rainfall會被設定為0，否則保持原來的值
            });

            // X軸
            const xScale = d3.scaleTime()
                             .domain(d3.extent(xData))
                             .range([margin, width - margin])
                             .nice();
            const xAxisGenerator = d3.axisBottom(xScale).tickFormat(d => d3.timeFormat("%Y/%m")(d)).ticks(6);
            const xAxis = svg.append("g")
                             .attr("transform", `translate(0, ${height - margin})`)
                             .call(xAxisGenerator);

            // Y軸
            const yScale = d3.scaleLinear()
                             .domain(d3.extent(yData))
                             .range([height - margin, margin])
                             .nice();
            const yAxisGenerator = d3.axisLeft(yScale).tickFormat(d => d + "mm");
            const yAxis = svg.append("g")
                             .attr("transform", `translate(${margin}, 0)`)
                             .call(yAxisGenerator);

            // 把資料按照name分組
            const sumName = d3.group(data, d => d.observatory);
            const color = d3.scaleOrdinal()
                            .domain(data.map(d => d.item))  // 此資料沒有item項，因此此同'.domain()'，即domain是空的
                            .range(d3.schemeCategory10);

            // 建立一個畫布範圍，超過此畫布的畫面都不會被渲染，這樣才能控制縮放的大小
            const clip = svg.append("defs")
                            .append("clipPath")
                            .attr("id", "d3jsMultiLineChartWithBrushClip")
                            .append("rect")
                            .attr("x", margin)
                            .attr("y", margin)
                            .attr("width", width - margin * 2)
                            .attr("height", height - margin * 2);

            // 設定brush
            const brush = d3.brushX()
                            .extent([[margin, margin], [width - margin, height - margin]])
                            .on("end", updateChart);

            // 開始建立折線圖
            const line = svg.append("g")

            // 畫上折線
            line.selectAll("path")
                .data(sumName)
                .join("path")
                .attr("class", "d3jsMultiLineChartWithBrusLine")
                .attr("d", d => {
                  return d3.line()
                           .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                           .y((d) => {
                             let rainfall = parseFloat(d.rainfall);
                             rainfall = rainfall || 0
                             return yScale(rainfall)
                           })(d[1])  // 因為是從sumName裡面取資料，除了觀測站（observatory）以外的資料都在d[1]裡
                })
                .attr("fill", "none")
                .attr("stroke", d => color(d))
                .attr("stroke-width", 1.5)
                .style("cursor", "pointer")

            // 加上brush
            line.attr("clip-path", "url(#d3jsMultiLineChartWithBrushClip)")
                .append("g")
                .attr("class", "d3jsMultiLineChartWithBrushBrush")
                .call(brush);

            // 設定brush後的動作
            function updateChart(e, d) {
              // xBrush的範圍，會回傳一個[x0, x1]的陣列
              const brushExtent = e.selection;
              if (brushExtent) {
                // xScale.invert是把回傳的x0和x1變成xScale接受的數值
                xScale.domain([xScale.invert(brushExtent[0]), (xScale.invert(brushExtent[1]))]);
                // 移除brush的灰色區域
                line.select(".d3jsMultiLineChartWithBrushBrush").call(brush.move, null);
              };

              // 按照更新的domain範圍值重新渲染圖表
              xAxis.transition().duration(1000).call(xAxisGenerator);
              line.selectAll(".d3jsMultiLineChartWithBrusLine")
                  .transition()
                  .duration(1000)
                  .attr("d", d => {
                    return d3.line()
                             .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                             .y((d) => {
                               let rainfall = parseFloat(d.rainfall);
                               rainfall = rainfall || 0;
                               return yScale(rainfall);
                             })(d[1])
                  });
            };

            // 雙擊svg縮回原本大小
            svg.on("dblclick", reset);

            function reset() {
              // 回到原本的大小
              xScale.domain(d3.extent(xData));

              // 重新呼叫渲染軸線和折線
              xAxis.transition().duration(1000).call(xAxisGenerator);
              line.selectAll(".d3jsMultiLineChartWithBrusLine")
                  .transition()
                  .duration(1000)
                  .attr("d", d => {
                    return d3.line()
                             .x((d) => xScale(d3.timeParse("%Y%m")(d.observeDate)))
                             .y((d) => {
                               let rainfall = parseFloat(d.rainfall);
                               rainfall = rainfall || 0;
                               return yScale(rainfall);
                             })(d[1])
                  });
            };
            
          };
          multiLineChartWithBrush();
        </script>
      </li>
    </ol>
  </body>
</html>